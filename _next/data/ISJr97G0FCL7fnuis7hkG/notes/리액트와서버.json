{"pageProps":{"totalNotes":[{"title":"리액트와 서버","slug":"리액트와서버","tags":[{"name":"react","slug":"react"},{"name":"dev","slug":"dev"},{"name":"coding","slug":"coding"}],"content":"\n# 리액트와 서버\n\n## 서버를 이용한 리액트 설계\n\n- 리액트는 UI 렌더링을 위한 라이브러리이지만 대부분의 앱에는 백엔드 서버가 필요하다.\n- 서버렌더링을 잘 이용하면 애플리케이션의 성능, 이식성 보안을 향상시킬 수 있다.\n\n- `ReactDOMServer.renderToString(element)` 메서드를 사용하면 UI를 서버에서 렌더링할 수 있다.\n- 서버에서는 브라우저에서 사용할 수 없는 많은 자원을 사용할 수 있고 브라우저보다 안전하다.\n- `hydrate(element, container[, callback])` 를 이용하면 클라이언트와 서버 쪽 렌더링을 함께 사용할 수 있는 하이브리드 경험이 가능하다.\n\n### ReactDOM 이란 ?\n\n- React 에서 DOM 관련 메서드를 제공하는 패키지로 `render()` 와 `hydate()` 등을 메서드로 제공한다.\n\n- render() : 이 함수는 `container` 안의 DOM 에 리액트 엘리먼트가 렌더링 된 후, 해당 컴포넌트에 대한 참조값을 제공한다.\n- hydrate() : render() 와 기본적으로 동일하게 작동하지만, ReactDOMServer 가 렌더링될 때 `container` 를 `hydrate(수화)` 하기 위해 사용된다. 리액트는 이벤트 리스너 등을 기존 마크업에 연결하여 동적 기능을 채워 넣는다.\n\n### ReactDOMServer\n\n- 정적 파일에 컴포넌트를 렌더링한다.\n- `renderToString()` 과 `renderToStaticMarkup()` 함수들은 서버와 브라우저 모두에서 사용할 수 있다.\n\n### CSR (클라이언트 사이드 렌더링)\n\n- CSR은 자바스크립트를 이용해 브라우저 상에서 페이지를 직접 렌더링한다.\n- 모든 로직과 데이터 페칭, 템플리팅, 라우팅 등이 클라이언트 쪽에서 처리된다.\n- CSR로 렌더링할 때 사용자는 페이지가 완전히 로딩될 때까지는 아무것도 표시되지 않은 빈 화면을 보게 된다.\n- 이는 사용자 경험에 안 좋은 영향을 끼치게 되어 페이지 이탈을 유발하고\n- 웹 크롤러 또한 빈 사이트를 인덱싱하지 못해 SEO 에도 좋지 않다.\n\n### SSR (서버 사이드 렌더링)\n\n- SSR 을 이용하면 페이지가 완전히 렌더링되기 이전에 먼저 서버를 이용해 앱의 HTML 데이터를 추출하여 브라우저에게 보내준다.\n- DB에서 데이터를 가져오고 HTML 페이지를 만들고 클라이언트에 보내는 이 모든 프로세스가 몇 밀리초 안에 벌어진다.\n- 따라서 사용자는 브라우저 화면을 열고 페이지를 보기까지 로딩 시간을 거의 느끼지 못할 것이다.\n- 다만 자바스크립트가 로드 되기 이전이므로 클릭과 같은 동적 기능은 이용할 수 없다.\n- 이는 사용자 이탈을 방지하고 SEO에도 좋다.\n\n### Hydration\n\n- render() 와 유사하게 작동하지만 빈 DOM 에 렌더링하는 대신, 모든 컴포넌트가 HTML 로 렌더링된 DOM에 내용을 채워넣는 방식이다.\n\n#### CSR의 경우\n\n```js\nconst root = document.querySelector('#root')\nReactDOM.render(<App name='Saeloun' />, root)\n```\n\n```js\n// 클라이언트에서 스크립트가 로딩되기 전의 상태\n<html>\n  <head></head>\n  <body>\n    <div id='root'></div>\n  </body>\n</html>\n```\n\n#### SSR 의 경우\n\n```js\n// index.js\nReactDOM.hydrate(<App name='Hello' />, document.getElementById('root'))\n\n// server.js\n\napp.use('/', (req, res, next) => {\n  fs.readFile(path.resolve('./build/index.html'), 'utf-8', (err, data) => {\n    if (err) {\n      console.error(err)\n      return res.status(500).send('Some error happend')\n    }\n    return res.send(ReactDOMServer.renderToString(<App name='hello' />))\n  })\n})\n\n// App.js\n\nexport default function App(props) {\n  return <div>Hello {props.name}</div>\n}\n\n// 클라이언트 사이드에서 스크립트가 로딩되기 전의 상태\n\n;<html>\n  <head></head>\n  <body>\n    <div id='root'>\n      <h1>Hello Saeloun!</h1>\n    </div>\n  </body>\n</html>\n```\n\n- CSR 은 자바스크립트가 완전히 로드되기 전에 사용자가 볼 수 있는 건 빈 화면 뿐이다.\n\n- SSR 에서는 서버에서 리액트 컴포넌트를 HTML 로 미리 렌더링하여 브라우저에 보낸다.\n- HTML 은 인터랙티브한 기능은 없지만 적어도 자바스크립트가 로딩되는 동안 페이지 레이아웃은 볼 수 있다\n- 자바스크립트 로딩이 완료되면 리액트는 HTML 에 이벤트 핸드러를 연결시키는 작업을 한다.\n- 이렇게 컴포넌트를 랜더링하고 이벤트 핸들러를 연결하는 과정을 `Hydaration` 이라고 한다.\n- 이는 '마른' HTML에 상호작용과 이벤트 핸들러로 '물'을 주는 것과 같다.\n- 하이드레이션 후, 비로소 앱은 인터랙티브 해진다.\n\n### Hydrate 의 과정\n\n1. 앱의 정적인 버전을 렌더링한다. (이를 통해 페이지가 완전히 로딩되기 전에 무언가를 사용자에게 보여줄 수 있다.)\n2. 동적 자바스크립트를 요청한다.\n3. 정적 콘텐츠를 동적 콘텐츠로 교체한다.\n4. 사용자가 콘텐츠 각 부분을 클릭하는 이벤트가 이제 정상 작동한다.\n\n### Hydration 사용의 장점\n\n1. 최초 로딩 시간 단축으로 좋은 사용자 경험\n2. SEO 향상\n\n_출처_\n\n- Learing React\n- https://velog.io/@hyemin916/%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%95%B1SSR%EC%9D%98-Hydration-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\n","notebook":"React js","createdAt":"Fri Sep 16 2022 09:00:00 GMT+0900 (Korean Standard Time)"}],"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    p: \"p\",\n    code: \"code\",\n    h3: \"h3\",\n    h4: \"h4\",\n    pre: \"pre\",\n    ol: \"ol\",\n    em: \"em\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"리액트와 서버\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"서버를 이용한 리액트 설계\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"리액트는 UI 렌더링을 위한 라이브러리이지만 대부분의 앱에는 백엔드 서버가 필요하다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"서버렌더링을 잘 이용하면 애플리케이션의 성능, 이식성 보안을 향상시킬 수 있다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.code, {\n            children: \"ReactDOMServer.renderToString(element)\"\n          }), \" 메서드를 사용하면 UI를 서버에서 렌더링할 수 있다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"서버에서는 브라우저에서 사용할 수 없는 많은 자원을 사용할 수 있고 브라우저보다 안전하다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.code, {\n            children: \"hydrate(element, container[, callback])\"\n          }), \" 를 이용하면 클라이언트와 서버 쪽 렌더링을 함께 사용할 수 있는 하이브리드 경험이 가능하다.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"ReactDOM 이란 ?\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"React 에서 DOM 관련 메서드를 제공하는 패키지로 \", _jsx(_components.code, {\n            children: \"render()\"\n          }), \" 와 \", _jsx(_components.code, {\n            children: \"hydate()\"\n          }), \" 등을 메서드로 제공한다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"render() : 이 함수는 \", _jsx(_components.code, {\n            children: \"container\"\n          }), \" 안의 DOM 에 리액트 엘리먼트가 렌더링 된 후, 해당 컴포넌트에 대한 참조값을 제공한다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"hydrate() : render() 와 기본적으로 동일하게 작동하지만, ReactDOMServer 가 렌더링될 때 \", _jsx(_components.code, {\n            children: \"container\"\n          }), \" 를 \", _jsx(_components.code, {\n            children: \"hydrate(수화)\"\n          }), \" 하기 위해 사용된다. 리액트는 이벤트 리스너 등을 기존 마크업에 연결하여 동적 기능을 채워 넣는다.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"ReactDOMServer\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"정적 파일에 컴포넌트를 렌더링한다.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"renderToString()\"\n        }), \" 과 \", _jsx(_components.code, {\n          children: \"renderToStaticMarkup()\"\n        }), \" 함수들은 서버와 브라우저 모두에서 사용할 수 있다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"CSR (클라이언트 사이드 렌더링)\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"CSR은 자바스크립트를 이용해 브라우저 상에서 페이지를 직접 렌더링한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"모든 로직과 데이터 페칭, 템플리팅, 라우팅 등이 클라이언트 쪽에서 처리된다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"CSR로 렌더링할 때 사용자는 페이지가 완전히 로딩될 때까지는 아무것도 표시되지 않은 빈 화면을 보게 된다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이는 사용자 경험에 안 좋은 영향을 끼치게 되어 페이지 이탈을 유발하고\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"웹 크롤러 또한 빈 사이트를 인덱싱하지 못해 SEO 에도 좋지 않다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"SSR (서버 사이드 렌더링)\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"SSR 을 이용하면 페이지가 완전히 렌더링되기 이전에 먼저 서버를 이용해 앱의 HTML 데이터를 추출하여 브라우저에게 보내준다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"DB에서 데이터를 가져오고 HTML 페이지를 만들고 클라이언트에 보내는 이 모든 프로세스가 몇 밀리초 안에 벌어진다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"따라서 사용자는 브라우저 화면을 열고 페이지를 보기까지 로딩 시간을 거의 느끼지 못할 것이다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"다만 자바스크립트가 로드 되기 이전이므로 클릭과 같은 동적 기능은 이용할 수 없다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이는 사용자 이탈을 방지하고 SEO에도 좋다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Hydration\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"render() 와 유사하게 작동하지만 빈 DOM 에 렌더링하는 대신, 모든 컴포넌트가 HTML 로 렌더링된 DOM에 내용을 채워넣는 방식이다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"CSR의 경우\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"const root = document.querySelector('#root')\\nReactDOM.render(<App name='Saeloun' />, root)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"// 클라이언트에서 스크립트가 로딩되기 전의 상태\\n<html>\\n  <head></head>\\n  <body>\\n    <div id='root'></div>\\n  </body>\\n</html>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"SSR 의 경우\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"// index.js\\nReactDOM.hydrate(<App name='Hello' />, document.getElementById('root'))\\n\\n// server.js\\n\\napp.use('/', (req, res, next) => {\\n  fs.readFile(path.resolve('./build/index.html'), 'utf-8', (err, data) => {\\n    if (err) {\\n      console.error(err)\\n      return res.status(500).send('Some error happend')\\n    }\\n    return res.send(ReactDOMServer.renderToString(<App name='hello' />))\\n  })\\n})\\n\\n// App.js\\n\\nexport default function App(props) {\\n  return <div>Hello {props.name}</div>\\n}\\n\\n// 클라이언트 사이드에서 스크립트가 로딩되기 전의 상태\\n\\n;<html>\\n  <head></head>\\n  <body>\\n    <div id='root'>\\n      <h1>Hello Saeloun!</h1>\\n    </div>\\n  </body>\\n</html>\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"CSR 은 자바스크립트가 완전히 로드되기 전에 사용자가 볼 수 있는 건 빈 화면 뿐이다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"SSR 에서는 서버에서 리액트 컴포넌트를 HTML 로 미리 렌더링하여 브라우저에 보낸다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"HTML 은 인터랙티브한 기능은 없지만 적어도 자바스크립트가 로딩되는 동안 페이지 레이아웃은 볼 수 있다\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"자바스크립트 로딩이 완료되면 리액트는 HTML 에 이벤트 핸드러를 연결시키는 작업을 한다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"이렇게 컴포넌트를 랜더링하고 이벤트 핸들러를 연결하는 과정을 \", _jsx(_components.code, {\n            children: \"Hydaration\"\n          }), \" 이라고 한다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"이는 '마른' HTML에 상호작용과 이벤트 핸들러로 '물'을 주는 것과 같다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"하이드레이션 후, 비로소 앱은 인터랙티브 해진다.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Hydrate 의 과정\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"앱의 정적인 버전을 렌더링한다. (이를 통해 페이지가 완전히 로딩되기 전에 무언가를 사용자에게 보여줄 수 있다.)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"동적 자바스크립트를 요청한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"정적 콘텐츠를 동적 콘텐츠로 교체한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"사용자가 콘텐츠 각 부분을 클릭하는 이벤트가 이제 정상 작동한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Hydration 사용의 장점\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"최초 로딩 시간 단축으로 좋은 사용자 경험\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"SEO 향상\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.em, {\n        children: \"출처\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Learing React\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"https://velog.io/@hyemin916/%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%95%B1SSR%EC%9D%98-Hydration-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"frontData":{"title":"리액트와 서버","notebook":"React js","tags":["react","dev","coding"],"createdAt":"2022-09-16"}},"__N_SSG":true}