{"pageProps":{"totalNotes":[{"title":"리액트와 서버","slug":"리액트와서버","tags":[{"name":"react","slug":"react"},{"name":"dev","slug":"dev"},{"name":"coding","slug":"coding"}],"content":"\n# 리액트와 서버\n\n## 서버를 이용한 리액트 설계\n\n- 리액트는 UI 렌더링을 위한 라이브러리이지만 대부분의 앱에는 백엔드 서버가 필요하다.\n- 서버렌더링을 잘 이용하면 애플리케이션의 성능, 이식성 보안을 향상시킬 수 있다.\n\n- `ReactDOMServer.renderToString(element)` 메서드를 사용하면 UI를 서버에서 렌더링할 수 있다.\n- 서버에서는 브라우저에서 사용할 수 없는 많은 자원을 사용할 수 있고 브라우저보다 안전하다.\n- `hydrate(element, container[, callback])` 를 이용하면 클라이언트와 서버 쪽 렌더링을 함께 사용할 수 있는 하이브리드 경험이 가능하다.\n\n### ReactDOM 이란 ?\n\n- React 에서 DOM 관련 메서드를 제공하는 패키지로 `render()` 와 `hydate()` 등을 메서드로 제공한다.\n\n- render() : 이 함수는 `container` 안의 DOM 에 리액트 엘리먼트가 렌더링 된 후, 해당 컴포넌트에 대한 참조값을 제공한다.\n- hydrate() : render() 와 기본적으로 동일하게 작동하지만, ReactDOMServer 가 렌더링될 때 `container` 를 `hydrate(수화)` 하기 위해 사용된다. 리액트는 이벤트 리스너 등을 기존 마크업에 연결하여 동적 기능을 채워 넣는다.\n\n### ReactDOMServer\n\n- 정적 파일에 컴포넌트를 렌더링한다.\n- `renderToString()` 과 `renderToStaticMarkup()` 함수들은 서버와 브라우저 모두에서 사용할 수 있다.\n\n### CSR (클라이언트 사이드 렌더링)\n\n- CSR은 자바스크립트를 이용해 브라우저 상에서 페이지를 직접 렌더링한다.\n- 모든 로직과 데이터 페칭, 템플리팅, 라우팅 등이 클라이언트 쪽에서 처리된다.\n- CSR로 렌더링할 때 사용자는 페이지가 완전히 로딩될 때까지는 아무것도 표시되지 않은 빈 화면을 보게 된다.\n- 이는 사용자 경험에 안 좋은 영향을 끼치게 되어 페이지 이탈을 유발하고\n- 웹 크롤러 또한 빈 사이트를 인덱싱하지 못해 SEO 에도 좋지 않다.\n\n### SSR (서버 사이드 렌더링)\n\n- SSR 을 이용하면 페이지가 완전히 렌더링되기 이전에 먼저 서버를 이용해 앱의 HTML 데이터를 추출하여 브라우저에게 보내준다.\n- DB에서 데이터를 가져오고 HTML 페이지를 만들고 클라이언트에 보내는 이 모든 프로세스가 몇 밀리초 안에 벌어진다.\n- 따라서 사용자는 브라우저 화면을 열고 페이지를 보기까지 로딩 시간을 거의 느끼지 못할 것이다.\n- 다만 자바스크립트가 로드 되기 이전이므로 클릭과 같은 동적 기능은 이용할 수 없다.\n- 이는 사용자 이탈을 방지하고 SEO에도 좋다.\n\n### Hydration\n\n- render() 와 유사하게 작동하지만 빈 DOM 에 렌더링하는 대신, 모든 컴포넌트가 HTML 로 렌더링된 DOM에 내용을 채워넣는 방식이다.\n\n#### CSR의 경우\n\n```js\nconst root = document.querySelector('#root')\nReactDOM.render(<App name='Saeloun' />, root)\n```\n\n```js\n// 클라이언트에서 스크립트가 로딩되기 전의 상태\n<html>\n  <head></head>\n  <body>\n    <div id='root'></div>\n  </body>\n</html>\n```\n\n#### SSR 의 경우\n\n```js\n// index.js\nReactDOM.hydrate(<App name='Hello' />, document.getElementById('root'))\n\n// server.js\n\napp.use('/', (req, res, next) => {\n  fs.readFile(path.resolve('./build/index.html'), 'utf-8', (err, data) => {\n    if (err) {\n      console.error(err)\n      return res.status(500).send('Some error happend')\n    }\n    return res.send(ReactDOMServer.renderToString(<App name='hello' />))\n  })\n})\n\n// App.js\n\nexport default function App(props) {\n  return <div>Hello {props.name}</div>\n}\n\n// 클라이언트 사이드에서 스크립트가 로딩되기 전의 상태\n\n;<html>\n  <head></head>\n  <body>\n    <div id='root'>\n      <h1>Hello Saeloun!</h1>\n    </div>\n  </body>\n</html>\n```\n\n- CSR 은 자바스크립트가 완전히 로드되기 전에 사용자가 볼 수 있는 건 빈 화면 뿐이다.\n\n- SSR 에서는 서버에서 리액트 컴포넌트를 HTML 로 미리 렌더링하여 브라우저에 보낸다.\n- HTML 은 인터랙티브한 기능은 없지만 적어도 자바스크립트가 로딩되는 동안 페이지 레이아웃은 볼 수 있다\n- 자바스크립트 로딩이 완료되면 리액트는 HTML 에 이벤트 핸드러를 연결시키는 작업을 한다.\n- 이렇게 컴포넌트를 랜더링하고 이벤트 핸들러를 연결하는 과정을 `Hydaration` 이라고 한다.\n- 이는 '마른' HTML에 상호작용과 이벤트 핸들러로 '물'을 주는 것과 같다.\n- 하이드레이션 후, 비로소 앱은 인터랙티브 해진다.\n\n### Hydrate 의 과정\n\n1. 앱의 정적인 버전을 렌더링한다. (이를 통해 페이지가 완전히 로딩되기 전에 무언가를 사용자에게 보여줄 수 있다.)\n2. 동적 자바스크립트를 요청한다.\n3. 정적 콘텐츠를 동적 콘텐츠로 교체한다.\n4. 사용자가 콘텐츠 각 부분을 클릭하는 이벤트가 이제 정상 작동한다.\n\n### Hydration 사용의 장점\n\n1. 최초 로딩 시간 단축으로 좋은 사용자 경험\n2. SEO 향상\n\n_출처_\n\n- Learing React\n- https://velog.io/@hyemin916/%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%95%B1SSR%EC%9D%98-Hydration-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\n","notebook":"React js","createdAt":"Fri Sep 16 2022 09:00:00 GMT+0900 (Korean Standard Time)"},{"title":"nest.js validation","slug":"nestjs-validation","tags":[{"name":"coding","slug":"coding"},{"name":"nest js","slug":"nest-js"},{"name":"validation","slug":"validation"}],"content":"\n### Pipes have two typical use cases:\n\n**transformation**: transform input data to the desired form (e.g., from string to integer)\n\n- 인수를 원하는 타입으로 변형\n  **validation**: evaluate input data and if valid, simply pass it through unchanged; otherwise, throw an exception when the data is incorrect\n\nIn both cases, pipes operate on the arguments being processed by a controller route handler. Nest interposes a pipe just before a method is invoked, and the pipe receives the arguments destined for the method and operates on them. Any transformation or validation operation takes place at that time, after which the route handler is invoked with any (potentially) transformed arguments.\n\n- 메소드가 호출되기 전에 파이프가 인수를 검증하거나 변형한다.\n\nHINT\nPipes run inside the exceptions zone. This means that when a Pipe throws an exception it is handled by the exceptions layer (global exceptions filter and any exceptions filters that are applied to the current context). Given the above, it should be clear that when an exception is thrown in a Pipe, no controller method is subsequently executed.\n\n- 파이프는 exception 존에서 실행되기 때문에 검증에서 예외가 발생하면 컨트롤 메서드는 동작하지 않는다.\n\nBuilt-in pipes\nNest comes with nine pipes available out-of-the-box:\n\nValidationPipe\nParseIntPipe\nParseFloatPipe\nParseBoolPipe\nParseArrayPipe\nParseUUIDPipe\nParseEnumPipe\nDefaultValuePipe\nParseFilePipe\n\n```ts\n@Get(':id')\n  findOne(\n    @Param(\n      'id',\n      new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE }),\n    )\n    id: number,\n  ) {\n    return `This action returns a #${id} cat`;\n  }\n```\n\n### Custom Pipe\n\n```ts\nv // alidation.pipe.ts\n\nimport { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common'\n\n@Injectable()\nexport class ValidationPipe implements PipeTransform {\n  transform(value: any, metadata: ArgumentMetadata) {\n    return value\n  }\n}\n```\n\n- The value parameter is the currently processed method argument (before it is received by the route handling method), and metadata is the currently processed method argument's metadata. The metadata object has these properties:\n\n```ts\nexport interface ArgumentMetadata {\n  type: 'body' | 'query' | 'param' | 'custom'\n  metatype?: Type<unknown>\n  data?: string\n}\n```\n\nWe want to ensure that any incoming request to the create method contains a valid body. So we have to validate the three members of the createCatDto object. We could do this inside the route handler method, but doing so is not ideal as it would break the single responsibility rule (SRP).\n\n### Object schema validation\n\nThere are several approaches available for doing object validation in a clean, DRY way. One common approach is to use schema-based validation. Let's go ahead and try that approach.\n\nThe Joi library allows you to create schemas in a straightforward way, with a readable API. Let's build a validation pipe that makes use of Joi-based schemas.\n\n```\n$ npm install --save joi\n$ npm install --save-dev @types/joi\n```\n\n### Class validator\n\nhttps://github.com/typestack/class-validator#usage\n\nNest works well with the class-validator library. This powerful library allows you to use decorator-based validation. Decorator-based validation is extremely powerful, especially when combined with Nest's Pipe capabilities since we have access to the metatype of the processed property. Before we start, we need to install the required packages:\n\n```\nnpm i class-validator class-transformer\n```\n\n```ts\nimport { IsString, IsInt } from 'class-validator'\n\nexport class CreateCatDto {\n  @IsString()\n  name: string\n\n  @IsInt()\n  age: number\n\n  @IsString()\n  breed: string\n}\n```\n","notebook":"nest js","createdAt":"Wed Aug 31 2022 09:00:00 GMT+0900 (Korean Standard Time)"},{"title":"ReactJS Unit Testing","slug":"React-Testing","tags":[{"name":"coding","slug":"coding"},{"name":"react-js","slug":"react-js"},{"name":"jest","slug":"jest"},{"name":"unit-testing","slug":"unit-testing"}],"content":"\n# [Learning React Ch.10] 리액트 테스트\n\nUnit Testing\n단위 테스팅을 통해 애플리케이션의 모든 부분 (또는 단위)이 의도대로 작동하는지 검증할 수 있음\n\n함수형 리액트는 테스트하기가 쉬움\n\n## 10.1 ESLint\n\n자바스크립트를 분석하는 과정을 힌팅 hinting 또는 린팅 linting 이라고 한다.\nESLint는 최신 자바스크립트 문법을 지원하는 코드 린터다.\nESLint는 플러그인을 추가할 수 있다.\n\n타입스크립트는 리액트 애플리케이션을 타입체킹하고 싶을 때 쓸 수 있는 또 다른 유명한 도구이다.\n타입스크립트는 자바스크립트의 하위집합이며 오픈 소스 언어이다. 따라서 타입스크립트 프로그램은 자바스크립트 프로그램이기도 하지만, 자바스크립트에 추가 기능을 제공한다.\n타입스크립트를 만든 목적은 큰 프로젝트에서 개발자가 좀 더 빨리 버그를 찾고 더 빠르게 개발 이터레이션이 가능하게 돕는 것이다.\n\n[ReactJS + Typescript Cheet Sheet](https://github.com/typescript-cheatsheets/react)\n\n## 10.4 테스트 주도 개발\n\n> 테스트 주도 개발 (TDD)은 기술이 아니다 TDD는 단지 애플리케이션을 위한 테스트를 갖추는 것만 뜻하지 않는다.\n> TDD는 모든 개발 과정을 테스트를 중심으로 진행해 나가는 습관이라고 할 수 있다.\n\n1. 테스트를 먼저 작성한다.\n   2 테스트를 실행하고 실패한다. (빨간색)\n   3 테스트를 통과하기 위해 필요한 최소한의 코드를 작성한다. (녹색)\n   4 코드와 테스트를 함께 리팩터링한다. (황금색\n\n- abc\n- dfasd\n- sdjlfsaldf\n\n1. 32\n2. 23\n3. sz\n\n> Quote here.\n>\n> <cite>- Benjamin Franklin</cite>\n\n## 10.5 제스트 사용하기\n\ntest 파일을 먼저 작성하고 코드를 짜고 테스트가 통과하는 걸 확인한다\n\n```tsx\n// function.js\nexport function order(items) {\n  const total = items.reduce((price, item) => price + item.price, 0)\n  return {\n    orderItems: items,\n    total,\n  }\n}\n\n// function.test.js\nimport { order } from './function'\n\nconst menuItems = [\n  {\n    id: '1',\n    name: 'Tatted Up Turkey Burger',\n    price: 5,\n  },\n  {\n    id: '2',\n    name: 'Lobster Lollipops',\n    price: 5,\n  },\n  {\n    id: '3',\n    name: 'Motley Quey plull porkt',\n    price: 5,\n  },\n]\n\nconst result = {\n  orderItems: menuItems,\n  total: 15,\n}\n\ntest('Build an order object', () => {\n  expect(order(menuItems)).toEqual(result)\n})\n```\n\ndescribe()\n이 함수는 관련이 있는 여러 테스트를 하나로 묶어준다. 예를 들어, 비슷한 함수에 대한 몇 가지 테스트가 있다면, describe 문장으로 모든 테스트를 감쌀 수 있다.\n그러면 테스트 러너가 테스트를 묶은 블록을 만들어준다. 이에 다라 터미널에 표시되는 출력 화면이 좀 더 조직적이고 읽기 쉬워 진다.\n\nTDD 사이클 : 테스트를 먼저 작성하고, 그 테스트를 통과하기 위한 코드를 작성한다.\n\n### 10.6 리액트 컴포넌트 테스트하기\n\n리액트 컴포넌트를 Jest 를 이용해 테스트 방법을 공부했다\n이를 이용해 리액트 DOM 엘리먼트들의 렌더링 결과들을 검증할 수 있다.\n리액트를 초기화할 때 setupTest 파일을 이용해 jest expect extend 를 쉽게 사용할 수 있다\n","notebook":"React js","createdAt":"Mon Aug 29 2022 09:00:00 GMT+0900 (Korean Standard Time)"},{"title":"Apollo Client","slug":"graphql-apollosdfkajsdfksfdkjsf","tags":[{"name":"apollo","slug":"apollo"},{"name":"dev","slug":"dev"},{"name":"coding","slug":"coding"}],"content":"\n## 아폴로 클라이언트에 대해서 알아보자\n\n아폴로 클라이언트는 무엇일까요?\n\n정말 궁금하다 !!\n\n```ts\nimport type { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport useSaveTotalNotes from '../hooks/useSaveTotalNotes'\nimport getTotalNotes from '../lib/getTotalNotes'\nimport { INote } from '../types/types'\nimport fs from 'fs'\nimport path from 'path'\nimport { NOTES_DIR } from '../constants/notebook.constants'\nimport matter from 'gray-matter'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport MDX from '../components/MDX'\ninterface HomeProps {\n  totalNotes: INote[]\n  metaData: { [key: string]: string }\n  source: MDXRemoteSerializeResult<Record<string, unknown>>\n}\nexport const getStaticProps: GetStaticProps = async () => {\n  const notes = fs.readdirSync(path.join(process.cwd(), NOTES_DIR))\n  const markdown = fs.readFileSync(\n    path.join(process.cwd(), NOTES_DIR, notes[notes.length - 1]),\n    'utf-8',\n  )\n  const { data: metaData, content } = matter(markdown)\n  const source = await serialize(content)\n  return {\n    props: {\n      totalNotes: getTotalNotes(),\n      source,\n      metaData,\n    },\n  }\n}\nconst Home = ({ totalNotes, source, metaData }: HomeProps) => {\n  useSaveTotalNotes(totalNotes)\n  return <MDX source={source} />\n}\n\nexport default Home\n```\n","notebook":"Apollo","createdAt":"Tue Aug 23 2022 09:00:00 GMT+0900 (Korean Standard Time)"},{"title":"hello Next.js","slug":"next","tags":[{"name":"coding","slug":"coding"},{"name":"next js","slug":"next-js"}],"content":"\n# Hello Next.js\n\n## 넥스트란 무엇일까?\n\n오늘은 Next.js 에 대해서 알아볼게요!\n\n```\nfunction NextApp() {\n  return <div>Hello World</div>\n}\n```\n\ndivd\n\n<br />\n\ndivd\n\n<br />\n\ndivd\n\n<br />\n\ndivd\n\n<br />\n","notebook":"Next js","createdAt":"Fri Aug 19 2022 09:00:00 GMT+0900 (Korean Standard Time)"},{"title":"hello React.js","slug":"react","tags":[{"name":"react","slug":"react"},{"name":"dev","slug":"dev"},{"name":"coding","slug":"coding"}],"content":"\n# Hello React.js\n\n## 리액트란 무엇일까?\n\n오늘은 리액트 js 에 대해서 알아볼게요!\n\n```\n\n```\n","notebook":"React js","createdAt":"Thu Aug 18 2022 09:00:00 GMT+0900 (Korean Standard Time)"},{"title":"About Me","slug":"about-me","tags":[],"content":"\n# Hello I'm Geony\n\n## This is me!\n","notebook":"","createdAt":"Thu Aug 18 2022 09:00:00 GMT+0900 (Korean Standard Time)"}]},"__N_SSG":true}