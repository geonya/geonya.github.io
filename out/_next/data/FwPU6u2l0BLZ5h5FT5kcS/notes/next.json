{"pageProps":{"totalNotes":[{"title":"nest.js validation","slug":"nestjs-validation","tags":[{"name":"coding","slug":"coding"},{"name":"nest js","slug":"nest-js"},{"name":"validation","slug":"validation"}],"content":"\n### Pipes have two typical use cases:\n\n**transformation**: transform input data to the desired form (e.g., from string to integer)\n\n- 인수를 원하는 타입으로 변형\n  **validation**: evaluate input data and if valid, simply pass it through unchanged; otherwise, throw an exception when the data is incorrect\n\nIn both cases, pipes operate on the arguments being processed by a controller route handler. Nest interposes a pipe just before a method is invoked, and the pipe receives the arguments destined for the method and operates on them. Any transformation or validation operation takes place at that time, after which the route handler is invoked with any (potentially) transformed arguments.\n\n- 메소드가 호출되기 전에 파이프가 인수를 검증하거나 변형한다.\n\nHINT\nPipes run inside the exceptions zone. This means that when a Pipe throws an exception it is handled by the exceptions layer (global exceptions filter and any exceptions filters that are applied to the current context). Given the above, it should be clear that when an exception is thrown in a Pipe, no controller method is subsequently executed.\n\n- 파이프는 exception 존에서 실행되기 때문에 검증에서 예외가 발생하면 컨트롤 메서드는 동작하지 않는다.\n\nBuilt-in pipes\nNest comes with nine pipes available out-of-the-box:\n\nValidationPipe\nParseIntPipe\nParseFloatPipe\nParseBoolPipe\nParseArrayPipe\nParseUUIDPipe\nParseEnumPipe\nDefaultValuePipe\nParseFilePipe\n\n```ts\n@Get(':id')\n  findOne(\n    @Param(\n      'id',\n      new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE }),\n    )\n    id: number,\n  ) {\n    return `This action returns a #${id} cat`;\n  }\n```\n\n### Custom Pipe\n\n```ts\nv // alidation.pipe.ts\n\nimport { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common'\n\n@Injectable()\nexport class ValidationPipe implements PipeTransform {\n  transform(value: any, metadata: ArgumentMetadata) {\n    return value\n  }\n}\n```\n\n- The value parameter is the currently processed method argument (before it is received by the route handling method), and metadata is the currently processed method argument's metadata. The metadata object has these properties:\n\n```ts\nexport interface ArgumentMetadata {\n  type: 'body' | 'query' | 'param' | 'custom'\n  metatype?: Type<unknown>\n  data?: string\n}\n```\n\nWe want to ensure that any incoming request to the create method contains a valid body. So we have to validate the three members of the createCatDto object. We could do this inside the route handler method, but doing so is not ideal as it would break the single responsibility rule (SRP).\n\n### Object schema validation\n\nThere are several approaches available for doing object validation in a clean, DRY way. One common approach is to use schema-based validation. Let's go ahead and try that approach.\n\nThe Joi library allows you to create schemas in a straightforward way, with a readable API. Let's build a validation pipe that makes use of Joi-based schemas.\n\n```\n$ npm install --save joi\n$ npm install --save-dev @types/joi\n```\n\n### Class validator\n\nhttps://github.com/typestack/class-validator#usage\n\nNest works well with the class-validator library. This powerful library allows you to use decorator-based validation. Decorator-based validation is extremely powerful, especially when combined with Nest's Pipe capabilities since we have access to the metatype of the processed property. Before we start, we need to install the required packages:\n\n```\nnpm i class-validator class-transformer\n```\n\n```ts\nimport { IsString, IsInt } from 'class-validator'\n\nexport class CreateCatDto {\n  @IsString()\n  name: string\n\n  @IsInt()\n  age: number\n\n  @IsString()\n  breed: string\n}\n```\n","notebook":"nest js","createdAt":"Wed Aug 31 2022 09:00:00 GMT+0900 (Korean Standard Time)"},{"title":"ReactJS Unit Testing","slug":"React-Testing","tags":[{"name":"coding","slug":"coding"},{"name":"react-js","slug":"react-js"},{"name":"jest","slug":"jest"},{"name":"unit-testing","slug":"unit-testing"}],"content":"\n# [Learning React Ch.10] 리액트 테스트\n\nUnit Testing\n단위 테스팅을 통해 애플리케이션의 모든 부분 (또는 단위)이 의도대로 작동하는지 검증할 수 있음\n\n함수형 리액트는 테스트하기가 쉬움\n\n## 10.1 ESLint\n\n자바스크립트를 분석하는 과정을 힌팅 hinting 또는 린팅 linting 이라고 한다.\nESLint는 최신 자바스크립트 문법을 지원하는 코드 린터다.\nESLint는 플러그인을 추가할 수 있다.\n\n타입스크립트는 리액트 애플리케이션을 타입체킹하고 싶을 때 쓸 수 있는 또 다른 유명한 도구이다.\n타입스크립트는 자바스크립트의 하위집합이며 오픈 소스 언어이다. 따라서 타입스크립트 프로그램은 자바스크립트 프로그램이기도 하지만, 자바스크립트에 추가 기능을 제공한다.\n타입스크립트를 만든 목적은 큰 프로젝트에서 개발자가 좀 더 빨리 버그를 찾고 더 빠르게 개발 이터레이션이 가능하게 돕는 것이다.\n\n[ReactJS + Typescript Cheet Sheet](https://github.com/typescript-cheatsheets/react)\n\n## 10.4 테스트 주도 개발\n\n> 테스트 주도 개발 (TDD)은 기술이 아니다 TDD는 단지 애플리케이션을 위한 테스트를 갖추는 것만 뜻하지 않는다.\n> TDD는 모든 개발 과정을 테스트를 중심으로 진행해 나가는 습관이라고 할 수 있다.\n\n1. 테스트를 먼저 작성한다.\n   2 테스트를 실행하고 실패한다. (빨간색)\n   3 테스트를 통과하기 위해 필요한 최소한의 코드를 작성한다. (녹색)\n   4 코드와 테스트를 함께 리팩터링한다. (황금색\n\n- abc\n- dfasd\n- sdjlfsaldf\n\n1. 32\n2. 23\n3. sz\n\n> Quote here.\n>\n> <cite>- Benjamin Franklin</cite>\n\n## 10.5 제스트 사용하기\n\ntest 파일을 먼저 작성하고 코드를 짜고 테스트가 통과하는 걸 확인한다\n\n```tsx\n// function.js\nexport function order(items) {\n  const total = items.reduce((price, item) => price + item.price, 0)\n  return {\n    orderItems: items,\n    total,\n  }\n}\n\n// function.test.js\nimport { order } from './function'\n\nconst menuItems = [\n  {\n    id: '1',\n    name: 'Tatted Up Turkey Burger',\n    price: 5,\n  },\n  {\n    id: '2',\n    name: 'Lobster Lollipops',\n    price: 5,\n  },\n  {\n    id: '3',\n    name: 'Motley Quey plull porkt',\n    price: 5,\n  },\n]\n\nconst result = {\n  orderItems: menuItems,\n  total: 15,\n}\n\ntest('Build an order object', () => {\n  expect(order(menuItems)).toEqual(result)\n})\n```\n\ndescribe()\n이 함수는 관련이 있는 여러 테스트를 하나로 묶어준다. 예를 들어, 비슷한 함수에 대한 몇 가지 테스트가 있다면, describe 문장으로 모든 테스트를 감쌀 수 있다.\n그러면 테스트 러너가 테스트를 묶은 블록을 만들어준다. 이에 다라 터미널에 표시되는 출력 화면이 좀 더 조직적이고 읽기 쉬워 진다.\n\nTDD 사이클 : 테스트를 먼저 작성하고, 그 테스트를 통과하기 위한 코드를 작성한다.\n\n### 10.6 리액트 컴포넌트 테스트하기\n\n리액트 컴포넌트를 Jest 를 이용해 테스트 방법을 공부했다\n이를 이용해 리액트 DOM 엘리먼트들의 렌더링 결과들을 검증할 수 있다.\n리액트를 초기화할 때 setupTest 파일을 이용해 jest expect extend 를 쉽게 사용할 수 있다\n","notebook":"React js","createdAt":"Mon Aug 29 2022 09:00:00 GMT+0900 (Korean Standard Time)"},{"title":"Apollo Client","slug":"graphql-apollosdfkajsdfksfdkjsf","tags":[{"name":"apollo","slug":"apollo"},{"name":"dev","slug":"dev"},{"name":"coding","slug":"coding"}],"content":"\n## 아폴로 클라이언트에 대해서 알아보자\n\n아폴로 클라이언트는 무엇일까요?\n\n정말 궁금하다 !!\n\n```ts\nimport type { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport useSaveTotalNotes from '../hooks/useSaveTotalNotes'\nimport getTotalNotes from '../lib/getTotalNotes'\nimport { INote } from '../types/types'\nimport fs from 'fs'\nimport path from 'path'\nimport { NOTES_DIR } from '../constants/notebook.constants'\nimport matter from 'gray-matter'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport MDX from '../components/MDX'\ninterface HomeProps {\n  totalNotes: INote[]\n  metaData: { [key: string]: string }\n  source: MDXRemoteSerializeResult<Record<string, unknown>>\n}\nexport const getStaticProps: GetStaticProps = async () => {\n  const notes = fs.readdirSync(path.join(process.cwd(), NOTES_DIR))\n  const markdown = fs.readFileSync(\n    path.join(process.cwd(), NOTES_DIR, notes[notes.length - 1]),\n    'utf-8',\n  )\n  const { data: metaData, content } = matter(markdown)\n  const source = await serialize(content)\n  return {\n    props: {\n      totalNotes: getTotalNotes(),\n      source,\n      metaData,\n    },\n  }\n}\nconst Home = ({ totalNotes, source, metaData }: HomeProps) => {\n  useSaveTotalNotes(totalNotes)\n  return <MDX source={source} />\n}\n\nexport default Home\n```\n","notebook":"Apollo","createdAt":"Tue Aug 23 2022 09:00:00 GMT+0900 (Korean Standard Time)"},{"title":"hello Next.js","slug":"next","tags":[{"name":"coding","slug":"coding"},{"name":"next js","slug":"next-js"}],"content":"\n# Hello Next.js\n\n## 넥스트란 무엇일까?\n\n오늘은 Next.js 에 대해서 알아볼게요!\n\n```\nfunction NextApp() {\n  return <div>Hello World</div>\n}\n```\n\ndivd\n\n<br />\n\ndivd\n\n<br />\n\ndivd\n\n<br />\n\ndivd\n\n<br />\n","notebook":"Next js","createdAt":"Fri Aug 19 2022 09:00:00 GMT+0900 (Korean Standard Time)"},{"title":"hello React.js","slug":"react","tags":[{"name":"react","slug":"react"},{"name":"dev","slug":"dev"},{"name":"coding","slug":"coding"}],"content":"\n# Hello React.js\n\n## 리액트란 무엇일까?\n\n오늘은 리액트 js 에 대해서 알아볼게요!\n\n```\n\n```\n","notebook":"React js","createdAt":"Thu Aug 18 2022 09:00:00 GMT+0900 (Korean Standard Time)"},{"title":"About Me","slug":"about-me","tags":[],"content":"\n# Hello I'm Geony\n\n## This is me!\n","notebook":"","createdAt":"Thu Aug 18 2022 09:00:00 GMT+0900 (Korean Standard Time)"}],"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Hello Next.js\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"넥스트란 무엇일까?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오늘은 Next.js 에 대해서 알아볼게요!\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"function NextApp() {\\n  return <div>Hello World</div>\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"divd\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"divd\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"divd\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"divd\"\n    }), \"\\n\", _jsx(\"br\", {})]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"frontData":{"title":"hello Next.js","notebook":"Next js","tags":["coding","next js"],"createdAt":"2022-08-19"}},"__N_SSG":true}